
import json
import os
import os.path
from subprocess import run, PIPE
import sys

def pid_to_comm_stime(pid):
    cp = run(['ps', '-q', str(pid), '-o', '%c|', '-o', 'stime'],
             stdout=PIPE, text=True)
    lines = cp.stdout.splitlines()
    if len(lines) < 2:
        return (None, None)
    else:
        return tuple(s.strip() for s in lines[1].split('|', 1))

class LockFile:
    def __init__(self, path):
        self.path = os.path.abspath(path)
        self.argv = sys.argv
        self.acquired = False

    def __enter__(self):
        try:
            with open(self.path, 'x') as f:
                self.acquired = True
                f.write(f'pid = {os.getpid():d}\n')
                f.write(f'argv = {json.dumps(self.argv)}\n')
        except FileExistsError:
            self.acquired = False
        if not self.acquired:
            with open(self.path, 'r') as f:
                pid = int(next(f).split('=', 1)[1].strip())
                argv = json.loads(next(f).split('=', 1)[1].strip())
            comm, stime = pid_to_comm_stime(int(pid))
            errormsg = f'Unable to acquire lock file "{self.path}". '
            errormsg += f'Lock file generated by process {pid}'
            if (comm is None):
                errormsg += ' which seems to have terminated.'
            else:
                errormsg += f' running since {stime}.'
            errormsg += f'\n  argv = {argv}'
            raise FileExistsError(errormsg)

    def __exit__(self, exc_type, exc_value, traceback):
        if self.acquired:
            os.unlink(self.path)
